"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Discovery = void 0;
const events_1 = require("events");
const discovery_protocols_1 = require("./discovery-protocols");
const caches_1 = require("./caches");
const logging_1 = require("./logging");
/**
 * Class responsible for discovering Axis cameras on the network.
 */
class Discovery {
    /**
     * Initializes a new instance of the class.
     */
    constructor() {
        this.eventEmitter = new events_1.EventEmitter();
        this.discoveryProtocols = [];
        this.deviceCache = new caches_1.DeviceCache();
        this.setup(new discovery_protocols_1.Bonjour());
        this.setup(new discovery_protocols_1.Ssdp());
    }
    /**
     * Start listen for device advertisements on all network interface
     * addresses.
     */
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            logging_1.log('Discovery#start');
            for (const discoveryProtocol of this.discoveryProtocols) {
                yield discoveryProtocol.start();
            }
        });
    }
    /**
     * Stop listening for device advertisements.
     */
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            logging_1.log('Discovery#stop');
            for (const discoveryProtocol of this.discoveryProtocols) {
                yield discoveryProtocol.stop();
            }
        });
    }
    /**
     * Triggers a new search for devices on the network.
     */
    search() {
        return __awaiter(this, void 0, void 0, function* () {
            logging_1.log('Discovery#search');
            for (const discoveryProtocol of this.discoveryProtocols) {
                yield discoveryProtocol.search();
            }
        });
    }
    /**
     * Alias for on(eventName, listener).
     */
    addListener(eventName, listener) {
        this.eventEmitter.addListener(eventName, listener);
        return this;
    }
    /**
     * Adds the listener function to the end of the listeners array for the event named eventName.
     * No checks are made to see if the listener has already been added. Multiple calls passing the
     * same combination of eventName and listener will result in the listener being added, and
     * called, multiple times.
     * @param eventName The name of the event.
     * @param listener The callback function.
     */
    on(eventName, listener) {
        this.eventEmitter.on(eventName, listener);
        return this;
    }
    /**
     * Adds a one-time listener function for the event named eventName. The next time eventName is
     * triggered, this listener is removed and then invoked.
     * @param eventName The name of the event.
     * @param listener The callback function.
     */
    once(eventName, listener) {
        this.eventEmitter.once(eventName, listener);
        return this;
    }
    /**
     * Alias for off(eventName, listener).
     * @param eventName The name of the event.
     * @param listener The callback function.
     */
    removeListener(eventName, listener) {
        this.eventEmitter.removeListener(eventName, listener);
        return this;
    }
    /**
     * Removes the specified listener from the listener array for the event named eventName.
     * @param eventName The name of the event.
     * @param listener The callback function.
     */
    off(eventName, listener) {
        this.eventEmitter.off(eventName, listener);
        return this;
    }
    /**
     * Removes all listeners, or those of the specified eventName.
     * @param eventName The name of the event.
     */
    removeAllListeners(eventName) {
        this.eventEmitter.removeAllListeners(eventName);
        return this;
    }
    /**
     * By default EventEmitters will print a warning if more than 10 listeners are added for a
     * particular event. This is a useful default that helps finding memory leaks. The
     * emitter.setMaxListeners() method allows the limit to be modified for this specific
     * EventEmitter instance. The value can be set to Infinity (or 0) to indicate an unlimited
     * number of listeners.
     */
    setMaxListeners(n) {
        this.eventEmitter.setMaxListeners(n);
        return this;
    }
    /**
     * Returns the current max listener value for the EventEmitter which is either set by
     * emitter.setMaxListeners(n) or defaults to EventEmitter.defaultMaxListeners.
     */
    getMaxListeners() {
        return this.eventEmitter.getMaxListeners();
    }
    /**
     * Returns a copy of the array of listeners for the event named eventName.
     * @param eventName The name of the event.
     */
    // tslint:disable-next-line:ban-types
    listeners(eventName) {
        return this.eventEmitter.listeners(eventName);
    }
    /**
     * Returns a copy of the array of listeners for the event named eventName, including any
     * wrappers (such as those created by once()).
     * @param eventName The name of the event.
     */
    // tslint:disable-next-line:ban-types
    rawListeners(eventName) {
        return this.eventEmitter.rawListeners(eventName);
    }
    /**
     * Synchronously calls each of the listeners registered for the event named eventName, in the
     * order they were registered, passing the supplied arguments to each.
     * @param eventName The name of the event.
     */
    emit(eventName, args) {
        return this.eventEmitter.emit(eventName, args);
    }
    /**
     * Returns the number of listeners listening to the event named eventName.
     * @param eventName The name of the event.
     */
    listenerCount(eventName) {
        return this.eventEmitter.listenerCount(eventName);
    }
    /**
     * Adds the listener function to the beginning of the listeners array for the event named
     * eventName. No checks are made to see if the listener has already been added. Multiple calls
     * passing the same combination of eventName and listener will result in the listener being
     * added, and called, multiple times.
     * @param eventName The name of the event.
     * @param listener The callback function.
     */
    prependListener(eventName, listener) {
        this.eventEmitter.prependListener(eventName, listener);
        return this;
    }
    /**
     * Adds a one-time listener function for the event named eventName to the beginning of the
     * listeners array. The next time eventName is triggered, this listener is removed, and then
     * invoked.
     * @param eventName The name of the event.
     * @param listener The callback function.
     */
    prependOnceListener(eventName, listener) {
        this.eventEmitter.prependOnceListener(eventName, listener);
        return this;
    }
    /**
     * Returns an array listing the events for which the emitter has registered listeners. The
     * values in the array are strings or Symbols.
     */
    eventNames() {
        return this.eventEmitter.eventNames();
    }
    setup(discoveryProtocol) {
        this.discoveryProtocols.push(discoveryProtocol);
        discoveryProtocol.onHello((device) => {
            device = this.deviceCache.update(device);
            this.eventEmitter.emit('hello', device);
        });
        discoveryProtocol.onGoodbye((device) => {
            device = this.deviceCache.update(device);
            this.eventEmitter.emit('goodbye', device);
        });
    }
}
exports.Discovery = Discovery;
//# sourceMappingURL=Discovery.js.map